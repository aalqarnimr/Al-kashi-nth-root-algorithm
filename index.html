<!DOCTYPE html>
<html lang="en" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      h1 {
        margin: 0px;
      }
      input#root-power {
        margin-right: 10px;
      }
      form {
        margin: 20px;
      }
      th {
        padding: 15px;
      }

      .end {
        grid-area: footer;
      }
      form button[type="button"] {
        margin-right: 15px;
        font-size: 20px;
        padding: 0 15px;
      }
      header {
        background-color: rosybrown;
        padding-right: 15px;
        padding: 25px;
        margin: 0;
        display: flex;
      }
      .table_container {
        display: flex;
        padding-right: 30px;
        /* flex-direction: column; */
        box-sizing: border-box;
        max-width: 100vw;
        width: 95vw;
        overflow-x: auto;
        overflow-y: auto;
      }
      tr,
      thead,
      th {
        border: 1px solid black;
      }
      .root-result {
        direction: ltr;
        padding-left: 20px;
        margin-bottom: 10px;
      }
      table {
        border: 1px solid black;
        border-top: none;
        border-left: none;
        border-right: none;
        overflow-x: auto;
        overflow-y: auto;
        margin-left: 35px;
      }
      .resultRow th {
        border-top: none;
        border-bottom: none;
      }
      .resultRow th:first-of-type {
        border-right: none;
      }
      .resultRow th:last-of-type {
        border-left: none;
      }
      tbody tr td,
      tfoot tr td {
        border-left: 1px solid black;
        border-right: 1px solid black;
        text-align: center;
        padding: 8px;
      }
      tbody tr td:last-of-type,
      tfoot tr td:last-of-type {
        border-left: 1px solid black;
      }
      .emptyRow td {
        padding: 30px;
      }
      .algorithm-result,
      .exact-result {
        margin-right: 20px;
      }
      tbody tr.end-row td {
        border-bottom: 3px double black;
      }
      .algorithm-result,
      .exact-result {
        display: none;
      }
      span {
        margin-right: 25px;
      }
      span button {
        font-size: larger;
        display: none;
      }
    </style>
  </head>
  <body>
    <header><h1>خوارزمية إيجاد الجذر النوني للكاشي</h1></header>
    <form>
      <p>
        <label for="whole">الرقم المجذور: </label>
        <input type="number" id="whole" />
      </p>
      <p>
        <label for="root-power">درجة الجذر: </label>
        <input type="number" id="root-power" />
      </p>
      <p>
        <button type="button" onclick="startAlgorithm()">أبدا</button>
      </p>
    </form>
    <hr />
    <span
      ><button class="previous">الخطوة السابقة</button
      ><button class="next" onclick="showStep()">الخطوة التالية</button></span
    >
    <div class="table_container">
      <table>
        <thead>
          <tr class="resultRow"></tr>
          <tr class="headRow"></tr>
        </thead>
        <tbody></tbody>
        <tfoot></tfoot>
      </table>
    </div>
    <hr />
    <p class="algorithm-result">
      ناتج الخوارزمية مع التقريب:
      <math>
        <mfrac>
          <msup>
            <mi class="numerator"></mi>
          </msup>
          <msup>
            <mi class="denominator"></mi>
          </msup>
        </mfrac>
      </math>
      <b class="whole-result"></b>
      ≈ <b class="approximate-result"></b>
    </p>
    <p class="exact-result">
      الناتج الحقيقي:
      <math>
        <mroot>
          <mi class="under-root"></mi>
          <mn class="root-degree"></mn>
        </mroot>
      </math>
      ≈ <b class="exact-result-solution"></b>
    </p>

    <script>
      const addCSS = (css) =>
        (document.head.appendChild(document.createElement("style")).innerHTML =
          css);
      function startAlgorithm() {
        resetTable();
        var whole = document.getElementById("whole").value;
        power = document.getElementById("root-power").valueAsNumber;
        let solution = Math.pow(whole, 1.0 / power);
        let solutionWhole = Math.floor(solution);
        let solutionWholeList = getDividedNumbers(solutionWhole).reverse();

        let solutionPoweredList = solutionWholeList.map((e) =>
          Math.pow(e, power)
        );
        tHeads = document.querySelectorAll("th");
        numbers = getDividedNumbers(whole);
        mergedNumbers = mergeNumbers(numbers, power);
        numOfmerged = mergedNumbers.length;
        headRow = document.querySelector(".headRow");
        resultRow = document.querySelector(".resultRow");
        bodyTable = document.querySelector("tbody");
        createRowCells(
          numbers,
          headRow,
          true,
          power - mergedNumbers[mergedNumbers.length - 1].toString().length
        );
        createRowCells(
          [],
          resultRow,
          true,
          Math.ceil(headRow.children.length / power),
          "",
          "after",
          power
        );
        maxWidth = headRow.children.length;
        firstNumber = headRow.lastChild;
        tableElement = document.querySelector("table");
        tableFooterElement = document.querySelector("tfoot");
        let [leasthNth, leastNthpowered] = [
          solutionWholeList[0],
          solutionPoweredList[0],
        ];
        //---------------------empty rows---------------------------------------
        emptyBodyRow = document.createElement("tr");
        emptyBodyRow.setAttribute("class", "emptyRow");
        createRowCells([], emptyBodyRow, false, maxWidth, "");

        removeBorder(emptyBodyRow.children, power);
        console.log(emptyBodyRow);

        lastDigit = resultRow.children[
          resultRow.children.length - 1
        ].innerText = leasthNth;
        //-------------------steps rows-------------------------------------------
        removeBorder(headRow.children, power);
        squaredList = getDividedNumbers(leastNthpowered);
        bodyRow = document.createElement("tr");
        bodyTable.appendChild(bodyRow);

        createRowCells(
          squaredList,
          bodyTable.children[0],
          false,
          headRow.children.length - power,
          "",
          "before-maxed",
          1,
          maxWidth
        );
        removeBorder(bodyRow.children, power);
        borderAroundNumber(bodyRow.children);
        console.log(bodyRow.children);

        let subtractResult = mergedNumbers[numOfmerged - 1] - leastNthpowered;
        subResultList = getDividedNumbers(subtractResult);
        subtractRow = document.createElement("tr");
        bodyTable.appendChild(subtractRow);
        createRowCells(
          subResultList,
          subtractRow,
          false,
          headRow.children.length - power,
          "",
          "before-maxed",
          1,
          maxWidth
        );
        removeBorder(subtractRow.children, power);

        // ---------------------footer------------------------------------------
        if (power === 2 || power === 1) {
          footerRow = document.createElement("tr");
          tableFooterElement.appendChild(footerRow);
          binomialCoefficientsList = binomialCoefficients(power);
          footerNum = leasthNth;
          listFooterNum = getDividedNumbers(footerNum);
          createRowCells(
            listFooterNum,
            tableFooterElement.children[0],
            false,
            headRow.children.length - power,
            "",
            "before-maxed",
            1,
            maxWidth
          );
          removeBorder(tableFooterElement.children[0].children, power);
          borderAroundNumber(tableFooterElement.children[0].children, true);
          footerNum = footerNum * 2;
          let oldFooterRow = footerRow;
          for (let i = 1; i < solutionWholeList.length; i++) {
            oldFooterRow = footerRow;
            footerNum = footerNum * 10 + solutionWholeList[i];
            let nextFooterNumList = getDividedNumbers(footerNum);
            footerRow = document.createElement("tr");
            tableFooterElement.prepend(footerRow);
            createRowCells(
              nextFooterNumList,
              footerRow,
              false,
              NumberIndex(oldFooterRow) - 2,
              "",
              "before-maxed",
              1,
              maxWidth
            );
            removeBorder(footerRow.children, power);
            appendToRow(resultRow, solutionWholeList[i]);
            lastFooterCells = [
              footerRow.children[NumberIndex(oldFooterRow) - 1],
              footerRow.children[NumberIndex(oldFooterRow) - 2],
            ];
            borderAroundNumber(lastFooterCells, true);

            multiplyResult = footerNum * solutionWholeList[i];
            multiplyResultList = getDividedNumbers(multiplyResult);
            let multiplyRow = createMaxedRow(
              multiplyResultList,
              NumberIndex(footerRow)
            );
            bodyTable.append(multiplyRow);
            let remainingWhole =
              100 * subtractResult + mergedNumbers[numOfmerged - 1 - i];
            console.log(mergedNumbers[numOfmerged - 1 - i]);
            subtractResult = remainingWhole - multiplyResult;
            let subtract2List = getDividedNumbers(subtractResult);
            subtractRow = createMaxedRow(subtract2List, NumberIndex(footerRow));
            bodyTable.append(subtractRow);
            borderAroundNumber(subtractRow.children, true);
            footerNum = footerNum + solutionWholeList[i];
          }
          bodyTable.append(emptyBodyRow);
        } else if (power >= 2) {
          let nextButton = document.querySelector(".next");
          let previousButton = document.querySelector(".previous");
          let step = 0;
          let tableStateList = [];
          let lastStep = numOfmerged - 1;
          document.querySelector("span .next").style.display = "inline";
          let binomialCoefficientList = [];
          let poweredList = getNumberPowerList(solutionWholeList[0]);
          let addedValue = 0;
          subtractRow.setAttribute("class", "end-row");
          let storedWhole = whole;
          let footerLastRow = createSection(power + 1, true);
          let lastRows = [];
          let targettedWhole = mergedNumbers[numOfmerged-1];
          let poweredNum = solutionWholeList[0];
          for (let i = 0; i < power - 2; i++) {
            lastRows.push(createSection(6 + 2 * i));
          }
          let lastRowsLength = lastRows.length;
          showStep();

          function showStep() {
            console.log("walkedhere" + step);
            console.log(headRow);
            let multipiers = multipierOf(
              solutionWholeList[step],
              addedValue,
              power
            );
            let shiftedMultipliers = multipiers.filter((e, i) => i != 0);
            multipendToRow(
              footerLastRow,
              multipiers[0],
              maxWidth - (step + 1) * power
            );
            let filledRows = fillRelativeRows(
              footerLastRow,
              shiftedMultipliers
            );
            filledRows.forEach((e) => borderAroundNumber(e.children));
            if (step != lastStep) {
              let clonedRow = fillRelative(
                filledRows[filledRows.length - 1],
                multipiers[power - 1]
              );
              shiftRow(clonedRow, power - 1);
            }
            binomialCoefficientList.push(shiftedMultipliers.pop());
            let previousList = shiftedMultipliers;
            for (let i = 1; i <= lastRowsLength; i++) {
              let activeSecRow = lastRows[lastRowsLength - i];
              let startingNumber = poweredList[i];
              multipendToRow(
                activeSecRow,
                startingNumber,
                maxWidth - (step + 1) * power
              );
              let operationList = nextSectionOperations(
                startingNumber,
                previousList,
                solutionWholeList[step]
              );
              filledRows = fillRelativeRows(activeSecRow, operationList);
              let filteredRows = filledRows.filter((e, i) => i % 2 == 1);
              filteredRows.forEach((e) => borderAroundNumber(e.children));
              let lastResult = operationList.pop();
              binomialCoefficientList.push(lastResult);
              previousList = SectionList(operationList);
              if (step != lastStep) {
                clonedRow = fillRelative(
                  filledRows[filledRows.length - 1],
                  lastResult
                );
                shiftRow(clonedRow, power - i - 1);
              }
            }
            tableCopy = tableElement.cloneNode(true);
            tableStateList.push(tableCopy);
            poweredList = binomialCoefficientList.map((e, i) =>
              Math.pow(e, i + 1)
            );
            binomialCoefficientList = [];
            addedValue += poweredList[0];
            let tempList = [];
            let temp2 = mergedNumbers.filter((e,i)=>i>step)
            
            whole = whole - solutionPoweredList[step]*Math.pow(10,(lastStep-step)*power);
            if (step != lastStep) {
              step += 1;
            }
            targettedWhole = targettedWhole*Math.pow(10,power) + mergedNumbers[numOfmerged-step-1];

            poweredNum = poweredNum*10 + solutionWholeList[step];
            let subtractResult = targettedWhole-Math.pow(poweredNum,power);
            let poweredResult = targettedWhole - Math.pow(poweredNum-solutionWholeList[step],power)-subtractResult;
            console.log(poweredResult, subtractResult,targettedWhole,poweredNum);
            clearTable();
            //whole = whole - solutionPoweredList[step]*Math.pow(10,(lastStep-step)*power);
            multipendToRow(headRow,whole);
          }
        }
        //--------------------------------------calculate----------------------------------------------------------------------------
        let algorithmBlock = document.querySelector(".algorithm-result");
        let exactBlock = document.querySelector(".exact-result");
        algorithmBlock.style.display = "block";
        exactBlock.style.display = "block";
        let powerDiffrence =
          Math.pow(solutionWhole + 1, power) - Math.pow(solutionWhole, power);
        let approximateFraction = subtractResult / powerDiffrence;
        let algWholeElement = document.querySelector(".whole-result");
        algWholeElement.innerText = solutionWhole;
        let numeratorA = document.querySelector(".numerator");
        console.log(numeratorA);
        numeratorA.innerHTML = subtractResult;
        let denominatorA = document.querySelector(".denominator");
        denominatorA.innerHTML = powerDiffrence;
        let approximateReslt = document.querySelector(".approximate-result");
        approximateReslt.innerText = approximateFraction + solutionWhole;
        let underRootElement = document.querySelector(".under-root");
        let rootPowerElement = document.querySelector(".root-degree");
        let exactResultElement = document.querySelector(
          ".exact-result-solution"
        );
        underRootElement.innerHTML = whole;
        rootPowerElement.innerHTML = power;
        exactResultElement.innerText = solution;
      }
      // .....................................................................
      // .....................................................................
      // .....................................................................
      // .....................................................................
      function getDividedNumbers(number) {
        var numbers = number
          .toString()
          .split("")
          .reverse()
          .map((e) => parseInt(e));
        return numbers;
      }
      function mergeNumbers(numbers, power) {
        var mergedNumbers = [];
        var index = 0;
        let lengthNumbers = numbers.length;
        while (index < lengthNumbers) {
          let number = 0;
          for (i = 0; i < power; i++) {
            if (index < lengthNumbers) {
              number += numbers[index] * Math.pow(10, i);
              index++;
            } else {
              number = number.toString();
            }
          }
          mergedNumbers.push(number);
        }
        return mergedNumbers;
      }
      function distributeNumbers(numbers, elements) {
        for ([index, element] of elements.entries()) {
          element.innerText = numbers[index];
        }
      }
      function leastNthRoot(number, power) {
        leastRoot = Math.floor(Math.pow(number, 1 / power));
        return [leastRoot, Math.pow(leastRoot, power)];
      }
      function* range(start, end) {
        for (let i = start; i < end; i++) {
          yield i;
        }
      }
      function createEmptyRow() {
        let emptyRow = document.createElement("tr");
        bodyTable.appendChild(emptyRow);
        createRowCells([], emptyRow, false, maxWidth, "");
        removeBorder(emptyRow.children, power);
        return emptyRow;
      }
      function createRowCells(
        numbersArr,
        row,
        isHead = false,
        extraCells = 0,
        extraCellsContent = 0,
        extraCellsPosition = "after",
        colspan = 1,
        maxLength = 1
      ) {
        if (isHead) {
          element = "th";
        } else {
          element = "td";
        }
        for (number of numbersArr) {
          tableCell = document.createElement(element);
          tableCell.appendChild(document.createTextNode(number));
          row.appendChild(tableCell);
          tableCell.setAttribute("colspan", colspan);
        }
        for (i of range(0, extraCells)) {
          tableCell = document.createElement(element);
          tableCell.appendChild(document.createTextNode(extraCellsContent));
          if (extraCellsPosition == "after") {
            row.appendChild(tableCell);
          }
          if (extraCellsPosition == "before") {
            $(row).prepend(tableCell);
          }
          if (extraCellsPosition == "before-maxed") {
            $(row).prepend(tableCell);
          }
          tableCell.setAttribute("colspan", colspan);
        }
        if (extraCellsPosition == "before-maxed") {
          remainingCells = maxLength - row.children.length;
          for (i of range(0, remainingCells)) {
            tableCell = document.createElement(element);
            tableCell.appendChild(document.createTextNode(extraCellsContent));
            row.appendChild(tableCell);
          }
        }
      }
      function createMaxedRow(
        contentList = [],
        offset = 0,
        { maxWidth = headRow.children.length } = {}
      ) {
        let i = 0;
        let newRow = createEmptyRow();
        newRowCells = newRow.children;
        for (element of contentList) {
          newRowCells[offset + i].innerText = element;
          i++;
        }
        return newRow;
      }
      function resetTable() {
        tableHeadRows = document.querySelectorAll("thead tr");
        for (row of tableHeadRows) {
          row.innerHTML = null;
        }
        document.querySelector("tbody").innerHTML = null;
        document.querySelector("tfoot").innerHTML = null;
        document.querySelector("span button").style.display = "none";
      }
      function setWidth(element, widthElement) {
        widthOfELement = widthElement.offsetWidth;
        element.style.width = widthOfELement + "px";
      }
      function removeBorder(cells, multipier) {
        activeCellIndex = 1;
        cellsLength = cells.length;
        while (activeCellIndex < cellsLength) {
          for (i of range(1, multipier)) {
            cells[activeCellIndex - 1].style.borderLeft = "none";
            cells[activeCellIndex].style.borderRight = "none";
            activeCellIndex++;
          }
          activeCellIndex++;
        }
      }

      function binomialCoefficients(power) {
        if (power < 0) {
          return [];
        }

        const coefficients = [];
        for (let i = 0; i <= power; i++) {
          coefficients.push(
            factorial(power) / (factorial(i) * factorial(power - i))
          );
        }

        return coefficients;
      }

      function factorial(n) {
        if (n === 0 || n === 1) {
          return 1;
        } else {
          return n * factorial(n - 1);
        }
      }
      function borderAroundNumber(cells, above = false) {
        for (cell of cells) {
          if (cell.innerText.length != 0) {
            if (above) {
              cell.style.borderTop = "2px solid grey";
            } else {
              cell.style.borderBottom = "2px solid grey";
            }
          }
        }
      }
      function shiftRow(row, offset) {
        let rowCells = row.children;
        let firstNumberIndex = NumberIndex(row);
        while (rowCells[firstNumberIndex].innerText != "") {
          rowCells[firstNumberIndex - offset].innerText =
            rowCells[firstNumberIndex].innerText;
          rowCells[firstNumberIndex].innerText = "";
          firstNumberIndex++;
        }
      }
      function cloneRow(row, direction = "below") {
        let newRow = document.createElement("tr");
        newRow.append(...row.children);
        if (direction == "below") {
          row.after(newRow);
        } else if ((direction = "above")) {
          row.before(newRow);
        }
        return newRow;
      }
      function appendToRow(row, content) {
        let firstOccurance = NumberIndex(row);
        if (firstOccurance != -1 || firstOccurance != 0) {
          row.children[firstOccurance - 1].innerText = content;
        } else {
          row.children[0].innerText = content;
        }
      }
      function NumberIndex(row, first = true) {
        let cells = row.children;
        let i = 0;
        for (cell of cells) {
          if (cell.innerText != "") {
            return i;
          }
          i++;
        }
        return -1;
      }
      function createSubtractRow(num1, num2, offset) {
        let subtractResults = num1 - num2;
        let subResultList = getDividedNumbers(subtractResults);
        newRow = createMaxedRow(subResultList, offset);
        shiftRow(newRow, offset);
        return newRow;
      }
      function transferRowNumbers(row, targetRow) {
        let rowChildren = row.children;
        let targetChildren = targetRow.children;
        let index = 0;
        for (cell of rowChildren) {
          if (cell.innerText != "") {
            targetChildren[index].innerText = cell.innerText;
          }
        }
      }
      function clearRow(targetRow) {
        let targetChildren = targetRow.children;
        for (cell of targetChildren) {
          cell.innerText = "";
        }
      }
      function transferRow(row, targetRow) {
        clearRow(targetRow);
        transferRowNumbers(row, targetRow);
      }
      function clearTable(exceptionRows = []) {
        clearRow(headRow);
        for (row of bodyTable.children) {
          if (!exceptionRows.includes(row)) {
            clearRow(row);
          }
        }
        for (footer of tableFooterElement.children) {
          if (!exceptionRows.includes(footer)) {
            clearRow(footer);
          }
        }
      }
      function extractNumber(targetRow) {
        let targetChildren = targetRow.children;
        let strNumber = "";
        for (cell in targetChildren) {
          if (cell.innerText != "") {
            str = cell.innerText + str;
          }
        }
        return parseInt(strNumber);
      }
      function fillRelative(targetRow, number, down = false, create = false) {
        let firstIndex = NumberIndex(targetRow);
        let wantedRow;
        if (create) {
          wantedRow = createMaxedRow(getDividedNumbers(number), firstIndex);
          if (down) {
            targetRow.after(wantedRow);
          } else {
            targetRow.before(wantedRow);
          }
        } else {
          wantedRow = getAdjacentRow(targetRow, down);
          multipendToRow(wantedRow, number, firstIndex);
        }
        return wantedRow;
      }
      function getAdjacentRow(targetRow, down = false) {
        let bodyRows = targetRow.parentElement.children;
        let adjacentRow;
        let targetRowIndex = Array.from(bodyRows).indexOf(targetRow);
        console.log(targetRowIndex);
        if (down) {
          adjacentRow = bodyRows[targetRowIndex + 1];
        } else {
          adjacentRow = bodyRows[targetRowIndex - 1];
        }
        return adjacentRow;
      }
      function multipendToRow(row, number, offset = 0) {
        let dividedNumbers = getDividedNumbers(number);
        let index = 0;
        let rowChildren = row.children;
        for (number of dividedNumbers) {
          rowChildren[index + offset].innerText = number;
          index++;
        }
      }
      function fillRelativeRows(
        targetRow,
        numbers,
        down = false,
        create = false
      ) {
        let filledRows = [];
        for (number of numbers) {
          targetRow = fillRelative(targetRow, number, down, create);
          filledRows.push(targetRow);
        }
        return filledRows;
      }
      function createSection(numberOfRows = 0, footer = false) {
        let rows = [];
        let row;
        for (let i = 0; i < numberOfRows; i++) {
          row = createEmptyRow();
          if (footer) {
            tableFooterElement.append(row);
          } else {
            bodyTable.append(row);
          }
          rows.push(row);
        }
        let endRow = rows[numberOfRows - 1];
        endRow.setAttribute("class", "end-row");
        return endRow;
        // if (!footer){
        //   doubleBorderBelow(endRow);
        // }
      }
      // function doubleBorderBelow(row) {
      //   let rowChildren = row.children;
      //   for (cell of rowChildren) {
      //     cell.style.borderBottom = "3px double black";
      //   }
      // }
      function multipierOf(number, addedNum, multipier) {
        let multipierList = [];
        for (let i = 1; i <= multipier; i++) {
          multipierList.push(addedNum + number * i);
        }
        return multipierList;
      }
      function nextSectionOperations(
        startingNumber,
        previousList,
        solutionNumber
      ) {
        let newList = [];
        previousListLength = previousList.length;
        for (let i = 0; i < previousListLength; i++) {
          let addedNumber = previousList[i] * solutionNumber;
          let newNumber = startingNumber + addedNumber;
          newList.push(addedNumber);
          newList.push(newNumber);
          startingNumber = newNumber;
        }
        return newList;
      }
      function SectionList(operationList) {
        let sectionList = operationList.filter((e, i) => i % 2 === 1);
        return sectionList;
      }
      function getNumberPowerList(number) {
        let powerList = [];
        for (let i = 1; i < power; i++) {
          powerList.push(Math.pow(number, i));
        }
        return powerList;
      }
      function fillCell(row, offset) {
        rowChildren = row.children;
        if (rowChildren[offset].innerText == "") {
          rowChildren[offset].innerText = " ";
        }
      }
    </script>
  </body>
</html>
